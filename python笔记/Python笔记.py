
直接使用复制方式，如a=[[1,2,3],[4,5,6]],则a是列表，并不是数组
>>>a=[[1,2,3],[4,5,6]]
>>>type(a)	# <class 'list'>

>>>import numpy as np
>>>a=np.array([[1,2,3],[4,5,6]])
>>>type(a)	# <class 'numpy.ndarray'>

======================================================================
只有数组类型可使用航宇列的提取，如x=data[:,0:-1],而列表不能这么做
当只取数组的某行或某列时，得到的是一个维度的数组，既不是行向量，也不是列向量，虽然得到的维度以一维行向量显示，但是将他转置后还是不变，还是以行向量的形式显示，但是使用x.reshape(-1,1)后可变为列向量。
x.shape    数组x的每个维度的大小，因为x可能不止二维的情况，比如RGB图像
x.shape[0] 数组x的行数，即第一维度
x.shape[1] 数组x的列数，即第二维度
x.shape[2] 数组x的第三维度大小，比如RGB图像第三维度大小为3
np.transpose(x)		求x的转置

=========================================================================
python中的几种取整的方法
fix 朝0方向取整   			>>>numpy.fix(3.4)   # 3.0	>>>numpy.fix(-3.4)    # -3.0
floor 朝负无穷方向取整		>>>numpy.floor(3.4) # 3.0	>>>numpy.floor(-3.4)  # -4.0
ceil朝正无穷方向取整		>>>numpy.ceil(3.4)  # 4.0	>>>numpy.floor(-3.4)  # -3.0
round 四舍五入取整			>>>round(3.4)		# 3		>>>round(3.5)		  #4.0	(有无numpy都可以)

===========================================================================
python中对数组或者range等，只能取到头，取不到尾（冒号后面的叫尾，即取不到冒号后面的）
range(4)  	#0,1,2,3
range(3,6)	#3,4,5

数组分片操作：设x是n*m的数组
x[0:3,:]	#取第0,1,2行的所有列元素，取不到第三行的
x[:-1,:]	#取第0到倒数第1行(但是取不到倒数第一行)的所有列
x[:,-1]		#取最后一列
-1	表示取的最后一行或者列，
0:-1表示取第0到最后一行或列但是取不到最后一行或列(因为只取头，取不到尾)

x[-1]和x[n-1]都表示去问最后一行
x[2:]表示取第二行到最后一行
x[:n]表示取第0行到第n-1行(取不到n)
x[-3:]表示取倒数第三行到最后一行(共取3行)
x[:-3]表示取第0行到倒数第三行(取不到-3即0到倒数第四行)
x[::2]表示从第0行开始，以步长为取行
x[3::2]表示从第3行开始，以步长为取行

================================================================================
原始字符串：在字符串前边加一个英文字母r即可
>>>str1=r'c:\now'	#如果不加r,字符串中的\n会被解释为换行符
>>>str		#'c:\\now'
>>>print(str1)	#c:\now

===============================================================================
sys.argv[]的使用方法：
比如某路径下有个文件test.py
必须在该路径下的命令行下执行 Python test.py 123  
会输出test.py   123
不能直接在python环境下运行，这样会报错，因为后面需要街上命令行参数，这参数需要人从键盘敲进去，即sys.argv[0]表示文件本身，sys.argv[1]表示命令行参数的第一个参数，以此类推
test.py文件有以下内容：
import sys
a=sys.argv[0]
b=sys.argv[1]
print(a)
print(b)

===================================================================================
python中，什么是*args和**kargs?如func(*args,**kargs)        
答：他俩是python中的可变参数。*args表示任意个无名参数，他是一个tuple;**kargs表示关键字参数，他是一个dict.并且当同时使用他俩时，必须*args参数列要在**kargs前，像func(a=1,b='2',1,None)会报错，因为这里a=1,b='2'是给关键字赋值了
当定义func(*args,**kargs)的形式之后，即必须先这么定义func()之后：         
func(1,2,3,4)  (1,2,3,4)是属于*args参数列的元组     
func(a=1,b=2)	( )空列表对应args,{'a':1,'b':2}对应kargs       
func(1,2,a=1)	(1,2)对应args, {'a':1}       
func('a',1,None,a=1,b='2')  ('a',1,,None)对应args;{'a':1'b':'2'}对应kargs      

=====================================================================================
在python版的opencv中，无论imread()读取的是什么格式图像(RGB,GRAY,...),imread()读取后都会变成三个通道。因为imread()默认读取RGB格式，即使原图是灰度图，读取后也会变成三个通道。因此，需要在imread()参数中添加一个可选参数0。例如imread('a.jpg',0)表示读取原图像格式     

======================================================================================
关于cv2.waitKey()       
python版opencv中，使用imshow()显示图片时，后面必须配合使用cv2.waitKey()和cv2.destroyAllWindow(),否则会出现未响应一类的情况。     
cv2.waitKey()在任意窗口下使用。一般用于显示图片后等待输入按键来销毁窗口。     
cv2.waitKey()的参数为等待键盘触发的时间，单位为ms，函数有返回值。  当没有按键按下时，返回-1；当某键例如('q')被按下时，返回该键ASCII码。在一些系统中，cv2.waitKey()的返回值可能比ASCII码的值更大。在所有系统中，可以通过读取返回值的最后一个字节来保证只提取ASCII码。具体代码如下：     
keycode=cv2.waitKey()      
'''if keycode!=-1      
	keycode&=0xff		#&是按位与运算
'''    
if cv2.waitKey()&0xff==ord('q')			#这里与oxff运算是为了提取ASCII码，因为不同系统可能不一样 #ord('q')返回113
	break		#若按下的键的ASCII与q的ASCII码相等，就执行break语句
	
'''ord()函数是以单个字符为参数，返回其对应的ASCII码；与ord()对应的chr()和unichr()[它与chr()不同的是返回unicode字符]以0到255整数做参数，返回对应字符。如chr(113)返回'q'。




	